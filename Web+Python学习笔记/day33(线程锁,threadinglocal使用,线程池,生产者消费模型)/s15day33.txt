s15day33 

内容回顾：
	1.Python的GIL锁
		- Python内置的一个全局解释器锁，锁的作用就是保证同一时刻一个进程中只有一个线程可以被cpu调度。
		为什么有这把GIL锁？
		答：Python语言的创始人在开发这门语言时，目的快速把语言开发出来，如果加上GIL锁（C语言加锁），切换时按照100条字节指令来进行线程间的切换。
		
	2. 进程和线程的区别？
		线程，cpu工作的最小单元。
		进程，为线程提供一个资源共享的空间。
		
		一个进程中默认是有一个主线程。
		
	3. 应用程序
	
	5. 编写多线程
	
	6. IO操作不占用CPU
	
	7. 进程和线程的使用准则：
		计算密集型：多进程
		  IO密集型：多线程
	
	8. 线程创建的越多越好吗？不好
		线程之间进行切换时，要做上下文管理。
		

今日内容：
	- 锁
		- 1次放1个
		- 1次放N个
		- 1次放动态N个
		- 1次所有放 
	- threading.local
	- 生产者消费者模型
	
内容详细：
	1. 锁：Lock (1次放1个)
	
		线程安全，多线程操作时，内部会让所有线程排队处理。如：list/dict/Queue
		线程不安全 + 人 => 排队处理。
		
		
		需求：
			a. 创建100个线程，在列表中追加8 
			b. 创建100个线程 
				v = []
				锁 
				- 把自己的添加到列表中。
				- 在读取列表的最后一个。
				解锁
		
		以后锁一个代码块：
			# by luffycity.com
			import threading
			import time
			v = []
			lock = threading.Lock()

			def func(arg):
				lock.acquire()
				v.append(arg)
				time.sleep(0.01)
				m = v[-1]
				print(arg,m)
				lock.release()

			for i in range(10):
				t =threading.Thread(target=func,args=(i,))
				t.start()
			
	2. 锁：RLock (1次放1个)
		
	3. 锁：BoundedSemaphore（1次放N个）信号量
		import time
		import threading

		lock = threading.BoundedSemaphore(3)
		def func(arg):
			lock.acquire()
			print(arg)
			time.sleep(1)
			lock.release()


		for i in range(20):
			t =threading.Thread(target=func,args=(i,))
			t.start()
			
	4. 锁：Condition（1次方法x个）
		
	5. 锁：Event（1次放所有）
	
	总结：
		线程安全，列表和字典线程安全；
		为什么要加锁？
			- 非线程安全
			- 控制一段代码
	
	6. threading.local
		作用：
			内部自动为每个线程维护一个空间（字典），用于当前存取属于自己的值。保证线程之间的数据隔离。
			{
				线程ID: {...}
				线程ID: {...}
				线程ID: {...}
				线程ID: {...}
			}
			
	
		示例：
			import time
			import threading

			v = threading.local()

			def func(arg):
				# 内部会为当前线程创建一个空间用于存储：phone=自己的值
				v.phone = arg
				time.sleep(2)
				print(v.phone,arg) # 去当前线程自己空间取值

			for i in range(10):
				t =threading.Thread(target=func,args=(i,))
				t.start()
			
	7. 线程池 
	
	8. 生产者消费者模型 
		三部件：
			生产者 
				队列，先进先出
					扩展： 栈，后进先出
			消费者 
		
		问：生产者消费者模型解决了什么问题？不用一直等待的问题。
			
	
		示例：
			# by luffycity.com
			import time
			import queue
			import threading
			q = queue.Queue() # 线程安全

			def producer(id):
				"""
				生产者
				:return:
				"""
				while True:
					time.sleep(2)
					q.put('包子')
					print('厨师%s 生产了一个包子' %id )

			for i in range(1,4):
				t = threading.Thread(target=producer,args=(i,))
				t.start()


			def consumer(id):
				"""
				消费者
				:return:
				"""
				while True:
					time.sleep(1)
					v1 = q.get()
					print('顾客 %s 吃了一个包子' % id)

			for i in range(1,3):
				t = threading.Thread(target=consumer,args=(i,))
				t.start()
	
	
重点总结：
	1. 锁 	***** 
	2. 线程安全 ***** 
	3. 线程池 *****
	4. threading.local ****
	5. 生成者消费者模型 ****























	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
